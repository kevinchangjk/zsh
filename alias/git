#! /bin/zsh

alias ga="git number add"
alias giti="nvim .gitignore"
alias gitm="nvim .gitmodules"
alias gl="git log --oneline --graph -n 10"
alias gaa="git add --all"
alias gau="git add -u"
alias ga.="git add ."
alias gap="git number add -p"
alias gb="git branch"
alias gc="git commit"
alias gcm="git commit -m"
alias gca="git commit --amend -m"
alias gco="git number checkout"
alias gd="git number diff"
alias gr="git number reset"
alias gs="git number" # git status
alias gp="git number -c nvim" # git preview
alias gu="git fetch && git number status" # git update
function gt() {
    tag_list=(
        css
        mdx
        js
        comp
        )
    [ "$1" = "e" ] && (nvim $REPOS/zsh/alias/git -c "/tag_list" && return) ||
    (for i in ${tag_list[@]}; do
        echo \[$i\]
    done)
}

# all git statuses
function ags() {
    CURRENT=$(pwd)
    cd $REPOS
    for d in */; do
        if [[ -d $d.git ]]; then
            cd $d
            commitStatus=$(git status 2> /dev/null | ag "nothing to commit, working tree clean")
            upToDate=$(git status 2> /dev/null | ag "Your branch is up to date with")
            if [[ -z $commitStatus ]]; then
                echo ${CYAN}"---"${NORMAL}
                echo -n ${GREEN}"repo: "${d%"/"} ${NORMAL}
                git status
                cd $REPOS
                unset commitStatus
            fi
            if [[ -z $upToDate ]]; then
                echo ${CYAN}"---"${NORMAL}
                echo -n ${GREEN}"repo: "${d%"/"} ${NORMAL}
                git status
                cd $REPOS
                unset upToDate
            fi
            cd $REPOS
            unset commitStatus
            unset upToDate
        fi
    done
    cd $CURRENT
    echo ${CYAN}"---"${NORMAL}
}

# delete branch with:
# git branch -d <branch_name>
#
# delete branch's remote with:
# git push origin -d <branch_name>
#
# add remote branch with:
# git switch <branch_name>
#
# 
# add (and clone) submodule with:
# git submodule add <submodule_name> <opt: dir_name>
# (this will also add a .gitmodule file)
#
# when cloning a repo containing submodules,
# you will get the submodules' directories,
# but they will be empty
# so run these:
# git submodule update --init
#
# and if these submodules has submodules of their own:
# git submodule update --init --recursive
#
# to update submodules:
# git submodule update --remote <submodule_name>
#
# or, just run this when cloning:
# git clone <repo> --recurse-submodules
#
# change submodule's branch:
# git config -f .gitmodules submodule.<submodule_name>.branch <branch_name>
#
# By default, the `git pull` command recursively fetches submodules changes, as we can see in the output of the first command above. However, it does not *update* the submodules.
# to finalize the update, run:
# git submodule update
#
# to remove a submodule completely:
# 0. mv a/submodule a/submodule_tmp
# 
# 1. git submodule deinit -f -- a/submodule    
# 2. rm -rf .git/modules/a/submodule
# 3. git rm -f a/submodule
# Note: a/submodule (no trailing slash)
# 
# or, if you want to leave it in your working tree and have done step 0
# 3.   git rm --cached a/submodule
# 3bis mv a/submodule_tmp a/submodule
