#! /bin/zsh

alias ga="git number add"
alias giti="$VIM .gitignore"
alias gitm="$VIM .gitmodules"
function gl() {
	if [ "$1" ]; then
		[ -z "${1//[0-9]}" ] && git log --oneline --graph -n $1
	else
		git log --oneline --graph -n 10
	fi

}
alias gaa="git add --all"
alias gau="git add -u"
alias ga.="git add ."
alias gap="git number add -p"
alias gb="git branch"
alias gc="git commit"
alias gcm="git commit -m"
alias gca="git commit --amend -m"
alias gco="git number checkout"
alias gd="git number diff"
alias gr="git number reset"
alias gs="git number" # git status
alias gp="git number -c $VIM" # git preview
alias gms="git merge --squash" # squash diff into one commit
alias gu="git fetch && git number status" # git update
function gt() {
    tag_list=(
        css
        mdx
        js
        comp
        )
    [ "$1" = "e" ] && ($VIM $REPOS/zsh/alias/git -c "/tag_list" && return) ||
    (for i in ${tag_list[@]}; do
        echo \[$i\]
    done)
}

# all git statuses
# function ags() {
#     blacklist=(
#       HCanoe/
#     )
#     cd $REPOS
#     for d in */; do
#         if [[ ${blacklist[(r)$d]} == $d ]]; then
#           continue
#         fi
#         if [[ -d $d.git ]]; then
#             cd $d
#             commitStatus=$(git status 2> /dev/null | ag "nothing to commit, working tree clean")
#             upToDate=$(git status 2> /dev/null | ag "Your branch is up to date with")
#             if [[ -z $commitStatus ]]; then
#                 echo ${CYAN}"---"${NORMAL}
#                 echo -n ${GREEN}"repo: "${d%"/"} ${NORMAL}
#                 git status
#                 cd $REPOS
#                 unset commitStatus
#             fi
#             if [[ -z $upToDate ]]; then
#                 echo ${CYAN}"---"${NORMAL}
#                 echo -n ${GREEN}"repo: "${d%"/"} ${NORMAL}
#                 git status
#                 cd $REPOS
#                 unset upToDate
#             fi
#             cd $REPOS
#             unset commitStatus
#             unset upToDate
#         fi
#     done
#     echo ${CYAN}"---"${NORMAL}
# }

function ags() {
  blacklist=(
    memelord
  )
  CURRENT=$(pwd)
  for d in $REPOS/*/; do
    cd $d
    CURRENT_REPO=$(pwd | awk -F/ '{print $NF}')
    [[ ${blacklist[(r)$CURRENT_REPO]} == $CURRENT_REPO ]] && continue
    gitStatus=$(git status --porcelain)
    if [ ! -z $gitStatus ]; then
      echo $YELLOW$(pwd | awk -F/ '{print $NF}')$NORMAL
      echo $gitStatus
    fi
  done
  cd $CURRENT
}

# delete branch with:
# git branch -d <branch_name>
#
# delete branch's remote with:
# git push origin -d <branch_name>
#
# add remote branch with:
# git switch <branch_name>
#
# 
# add (and clone) submodule with:
# git submodule add <submodule_name> <opt: dir_name>
# (this will also add a .gitmodule file)
#
# when cloning a repo containing submodules,
# you will get the submodules' directories,
# but they will be empty
# so run these:
# git submodule update --init
#
# and if these submodules has submodules of their own:
# git submodule update --init --recursive
#
# to update submodules:
# git submodule update --remote <submodule_name>
#
# or, just run this when cloning:
# git clone <repo> --recurse-submodules
#
# change submodule's branch:
# git config -f .gitmodules submodule.<submodule_name>.branch <branch_name>
#
# By default, the `git pull` command recursively fetches submodules changes, as we can see in the output of the first command above. However, it does not *update* the submodules.
# to finalize the update, run:
# git submodule update
#
# to remove a submodule completely:
# 0. mv a/submodule a/submodule_tmp
# 
# 1. git submodule deinit -f -- a/submodule    
# 2. rm -rf .git/modules/a/submodule
# 3. git rm -f a/submodule
# Note: a/submodule (no trailing slash)
# 
# or, if you want to leave it in your working tree and have done step 0
# 3.   git rm --cached a/submodule
# 3bis mv a/submodule_tmp a/submodule
