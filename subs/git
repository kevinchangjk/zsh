#! /bin/zsh

function gl() {
	if [ "$1" ]; then
		[ -z "${1//[0-9]}" ] && git log --oneline --graph -n $1
	else
		git log --oneline --graph -n 10
	fi

}

alias gs="git number" # git status
alias ga="git number add"
alias gaa="git add --all"
alias gco="git number checkout"
alias gb="git branch"

alias gca="git commit --amend -m"
alias gd="git number diff"
alias gds="git number diff --staged"
alias giti="$VIM .gitignore"
alias gr="git number reset"
alias gitm="$VIM .gitmodules"
alias gp="git number -c $VIM" # git preview

alias gap="git number add -p"
alias gms="git merge --squash" # squash diff into one commit

alias gu="git fetch && git number status" # git update
alias gc="git commit"
alias gau="git add -u"
alias ga.="git add ."

function gcm() {
  if [[ "$1" = "" ]]; then
    git commit
  else
    git commit -m $1
  fi
}
function ags() {
  MAX_LEN=18
  blacklist=(
    HCanoe
    material-design-icons
    nusmods
    docusaurus
    iTerm2-Color-Schemes
  )
  CURRENT=$(pwd)
  for d in $REPOS/*/; do
    cd $d
    CURRENT_REPO=$(pwd | awk -F/ '{print $NF}')
    STR_LEN=$(echo -n $CURRENT_REPO | wc -m)
    [[ ${blacklist[(r)$CURRENT_REPO]} == $CURRENT_REPO ]] && continue
    gitStatus=$(git status -s)
    gitRemote=()
    while IFS= read -r line; do
      gitRemote+=( "$line" )
    done < <( git cherry -v --abbrev 2> /dev/null )
    # uncommitted changes
    if [ ! -z $gitStatus ]; then
      echo $CYAN$(pwd | awk -F/ '{print $NF}')$NORMAL
      echo $gitStatus
    # unpushed commits
    elif [ ! -z $gitRemote[1] ]; then
      echo $CYAN$(pwd | awk -F/ '{print $NF}')$NORMAL
      for i in $gitRemote[@]; do
        pre=$(echo $i | cut -d ' ' -f1)
        post=$(echo $i | cut -d ' ' -f3-)
        commit=$(echo $i | cut -d ' ' -f2)
        commit=$YELLOW${commit}$NORMAL
        echo $pre $commit $post
      done
    else
      DOT_LEN=$(echo $(( MAX_LEN - STR_LEN )))
      PRINT_DOT=$(printf ' %.0s' {1..$DOT_LEN})
      echo $CYAN$(pwd | awk -F/ '{print $NF}')${NORMAL}$PRINT_DOT${GREEN}"[ok]"$NORMAL
    fi
  done
  cd $CURRENT
  return true
}

# delete branch with:
# git branch -d <branch_name>
#
# delete branch's remote with:
# git push origin -d <branch_name>
#
# add remote branch with:
# git switch <branch_name>
#
# 
# add (and clone) submodule with:
# git submodule add <submodule_name> <opt: dir_name>
# (this will also add a .gitmodule file)
#
# when cloning a repo containing submodules,
# you will get the submodules' directories,
# but they will be empty
# so run these:
# git submodule update --init
#
# and if these submodules has submodules of their own:
# git submodule update --init --recursive
#
# to update submodules:
# git submodule update --remote <submodule_name>
#
# or, just run this when cloning:
# git clone <repo> --recurse-submodules
#
# change submodule's branch:
# git config -f .gitmodules submodule.<submodule_name>.branch <branch_name>
#
# By default, the `git pull` command recursively fetches submodules changes, as we can see in the output of the first command above. However, it does not *update* the submodules.
# to finalize the update, run:
# git submodule update
#
# to remove a submodule completely:
# 0. mv a/submodule a/submodule_tmp
# 
# 1. git submodule deinit -f -- a/submodule    
# 2. rm -rf .git/modules/a/submodule
# 3. git rm -f a/submodule
# Note: a/submodule (no trailing slash)
# 
# or, if you want to leave it in your working tree and have done step 0
# 3.   git rm --cached a/submodule
# 3bis mv a/submodule_tmp a/submodule
